-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Contracts.UniSwapGraph.Subscription exposing (..)

import Contracts.UniSwapGraph.Enum.Bundle_orderBy
import Contracts.UniSwapGraph.Enum.Burn_orderBy
import Contracts.UniSwapGraph.Enum.LiquidityPositionSnapshot_orderBy
import Contracts.UniSwapGraph.Enum.LiquidityPosition_orderBy
import Contracts.UniSwapGraph.Enum.Mint_orderBy
import Contracts.UniSwapGraph.Enum.OrderDirection
import Contracts.UniSwapGraph.Enum.PairDayData_orderBy
import Contracts.UniSwapGraph.Enum.PairHourData_orderBy
import Contracts.UniSwapGraph.Enum.Pair_orderBy
import Contracts.UniSwapGraph.Enum.Swap_orderBy
import Contracts.UniSwapGraph.Enum.TokenDayData_orderBy
import Contracts.UniSwapGraph.Enum.Token_orderBy
import Contracts.UniSwapGraph.Enum.Transaction_orderBy
import Contracts.UniSwapGraph.Enum.UniswapDayData_orderBy
import Contracts.UniSwapGraph.Enum.UniswapFactory_orderBy
import Contracts.UniSwapGraph.Enum.User_orderBy
import Contracts.UniSwapGraph.InputObject
import Contracts.UniSwapGraph.Interface
import Contracts.UniSwapGraph.Object
import Contracts.UniSwapGraph.Scalar
import Contracts.UniSwapGraph.ScalarCodecs
import Contracts.UniSwapGraph.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias UniswapFactoryOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias UniswapFactoryRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
uniswapFactory :
    (UniswapFactoryOptionalArguments -> UniswapFactoryOptionalArguments)
    -> UniswapFactoryRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.UniswapFactory
    -> SelectionSet (Maybe decodesTo) RootSubscription
uniswapFactory fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "uniswapFactory" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias UniswapFactoriesOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.UniswapFactory_orderBy.UniswapFactory_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.UniswapFactory_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
uniswapFactories :
    (UniswapFactoriesOptionalArguments -> UniswapFactoriesOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.UniswapFactory
    -> SelectionSet (List decodesTo) RootSubscription
uniswapFactories fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.UniswapFactory_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeUniswapFactory_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "uniswapFactories" optionalArgs object_ (identity >> Decode.list)


type alias TokenOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias TokenRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
token :
    (TokenOptionalArguments -> TokenOptionalArguments)
    -> TokenRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Token
    -> SelectionSet (Maybe decodesTo) RootSubscription
token fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "token" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias TokensOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Token_orderBy.Token_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Token_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
tokens :
    (TokensOptionalArguments -> TokensOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Token
    -> SelectionSet (List decodesTo) RootSubscription
tokens fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Token_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeToken_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tokens" optionalArgs object_ (identity >> Decode.list)


type alias PairOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias PairRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pair :
    (PairOptionalArguments -> PairOptionalArguments)
    -> PairRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Pair
    -> SelectionSet (Maybe decodesTo) RootSubscription
pair fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pair" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias PairsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Pair_orderBy.Pair_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Pair_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pairs :
    (PairsOptionalArguments -> PairsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Pair
    -> SelectionSet (List decodesTo) RootSubscription
pairs fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Pair_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodePair_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pairs" optionalArgs object_ (identity >> Decode.list)


type alias UserOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias UserRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
user :
    (UserOptionalArguments -> UserOptionalArguments)
    -> UserRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.User
    -> SelectionSet (Maybe decodesTo) RootSubscription
user fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "user" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias UsersOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.User_orderBy.User_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.User_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
users :
    (UsersOptionalArguments -> UsersOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.User
    -> SelectionSet (List decodesTo) RootSubscription
users fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.User_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeUser_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "users" optionalArgs object_ (identity >> Decode.list)


type alias LiquidityPositionOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias LiquidityPositionRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
liquidityPosition :
    (LiquidityPositionOptionalArguments -> LiquidityPositionOptionalArguments)
    -> LiquidityPositionRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.LiquidityPosition
    -> SelectionSet (Maybe decodesTo) RootSubscription
liquidityPosition fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "liquidityPosition" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias LiquidityPositionsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.LiquidityPosition_orderBy.LiquidityPosition_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.LiquidityPosition_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
liquidityPositions :
    (LiquidityPositionsOptionalArguments -> LiquidityPositionsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.LiquidityPosition
    -> SelectionSet (List decodesTo) RootSubscription
liquidityPositions fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.LiquidityPosition_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeLiquidityPosition_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "liquidityPositions" optionalArgs object_ (identity >> Decode.list)


type alias LiquidityPositionSnapshotOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias LiquidityPositionSnapshotRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
liquidityPositionSnapshot :
    (LiquidityPositionSnapshotOptionalArguments -> LiquidityPositionSnapshotOptionalArguments)
    -> LiquidityPositionSnapshotRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.LiquidityPositionSnapshot
    -> SelectionSet (Maybe decodesTo) RootSubscription
liquidityPositionSnapshot fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "liquidityPositionSnapshot" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias LiquidityPositionSnapshotsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.LiquidityPositionSnapshot_orderBy.LiquidityPositionSnapshot_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.LiquidityPositionSnapshot_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
liquidityPositionSnapshots :
    (LiquidityPositionSnapshotsOptionalArguments -> LiquidityPositionSnapshotsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.LiquidityPositionSnapshot
    -> SelectionSet (List decodesTo) RootSubscription
liquidityPositionSnapshots fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.LiquidityPositionSnapshot_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeLiquidityPositionSnapshot_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "liquidityPositionSnapshots" optionalArgs object_ (identity >> Decode.list)


type alias TransactionOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias TransactionRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
transaction :
    (TransactionOptionalArguments -> TransactionOptionalArguments)
    -> TransactionRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Transaction
    -> SelectionSet (Maybe decodesTo) RootSubscription
transaction fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "transaction" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias TransactionsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Transaction_orderBy.Transaction_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Transaction_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
transactions :
    (TransactionsOptionalArguments -> TransactionsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Transaction
    -> SelectionSet (List decodesTo) RootSubscription
transactions fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Transaction_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeTransaction_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "transactions" optionalArgs object_ (identity >> Decode.list)


type alias MintOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias MintRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
mint :
    (MintOptionalArguments -> MintOptionalArguments)
    -> MintRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Mint
    -> SelectionSet (Maybe decodesTo) RootSubscription
mint fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "mint" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias MintsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Mint_orderBy.Mint_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Mint_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
mints :
    (MintsOptionalArguments -> MintsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Mint
    -> SelectionSet (List decodesTo) RootSubscription
mints fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Mint_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeMint_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "mints" optionalArgs object_ (identity >> Decode.list)


type alias BurnOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias BurnRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
burn :
    (BurnOptionalArguments -> BurnOptionalArguments)
    -> BurnRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Burn
    -> SelectionSet (Maybe decodesTo) RootSubscription
burn fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "burn" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias BurnsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Burn_orderBy.Burn_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Burn_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
burns :
    (BurnsOptionalArguments -> BurnsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Burn
    -> SelectionSet (List decodesTo) RootSubscription
burns fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Burn_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeBurn_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "burns" optionalArgs object_ (identity >> Decode.list)


type alias SwapOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias SwapRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
swap :
    (SwapOptionalArguments -> SwapOptionalArguments)
    -> SwapRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Swap
    -> SelectionSet (Maybe decodesTo) RootSubscription
swap fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "swap" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias SwapsOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Swap_orderBy.Swap_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Swap_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
swaps :
    (SwapsOptionalArguments -> SwapsOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Swap
    -> SelectionSet (List decodesTo) RootSubscription
swaps fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Swap_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeSwap_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "swaps" optionalArgs object_ (identity >> Decode.list)


type alias BundleOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias BundleRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
bundle :
    (BundleOptionalArguments -> BundleOptionalArguments)
    -> BundleRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Bundle
    -> SelectionSet (Maybe decodesTo) RootSubscription
bundle fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "bundle" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias BundlesOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.Bundle_orderBy.Bundle_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.Bundle_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
bundles :
    (BundlesOptionalArguments -> BundlesOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.Bundle
    -> SelectionSet (List decodesTo) RootSubscription
bundles fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.Bundle_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeBundle_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "bundles" optionalArgs object_ (identity >> Decode.list)


type alias UniswapDayDataOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias UniswapDayDataRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
uniswapDayData :
    (UniswapDayDataOptionalArguments -> UniswapDayDataOptionalArguments)
    -> UniswapDayDataRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.UniswapDayData
    -> SelectionSet (Maybe decodesTo) RootSubscription
uniswapDayData fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "uniswapDayData" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias UniswapDayDatasOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.UniswapDayData_orderBy.UniswapDayData_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.UniswapDayData_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
uniswapDayDatas :
    (UniswapDayDatasOptionalArguments -> UniswapDayDatasOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.UniswapDayData
    -> SelectionSet (List decodesTo) RootSubscription
uniswapDayDatas fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.UniswapDayData_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeUniswapDayData_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "uniswapDayDatas" optionalArgs object_ (identity >> Decode.list)


type alias PairHourDataOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias PairHourDataRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pairHourData :
    (PairHourDataOptionalArguments -> PairHourDataOptionalArguments)
    -> PairHourDataRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.PairHourData
    -> SelectionSet (Maybe decodesTo) RootSubscription
pairHourData fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pairHourData" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias PairHourDatasOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.PairHourData_orderBy.PairHourData_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.PairHourData_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pairHourDatas :
    (PairHourDatasOptionalArguments -> PairHourDatasOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.PairHourData
    -> SelectionSet (List decodesTo) RootSubscription
pairHourDatas fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.PairHourData_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodePairHourData_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pairHourDatas" optionalArgs object_ (identity >> Decode.list)


type alias PairDayDataOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias PairDayDataRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pairDayData :
    (PairDayDataOptionalArguments -> PairDayDataOptionalArguments)
    -> PairDayDataRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.PairDayData
    -> SelectionSet (Maybe decodesTo) RootSubscription
pairDayData fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pairDayData" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias PairDayDatasOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.PairDayData_orderBy.PairDayData_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.PairDayData_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
pairDayDatas :
    (PairDayDatasOptionalArguments -> PairDayDatasOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.PairDayData
    -> SelectionSet (List decodesTo) RootSubscription
pairDayDatas fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.PairDayData_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodePairDayData_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pairDayDatas" optionalArgs object_ (identity >> Decode.list)


type alias TokenDayDataOptionalArguments =
    { block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height }


type alias TokenDayDataRequiredArguments =
    { id : Contracts.UniSwapGraph.ScalarCodecs.Id }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
tokenDayData :
    (TokenDayDataOptionalArguments -> TokenDayDataOptionalArguments)
    -> TokenDayDataRequiredArguments
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.TokenDayData
    -> SelectionSet (Maybe decodesTo) RootSubscription
tokenDayData fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { block = Absent }

        optionalArgs =
            [ Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tokenDayData" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (Contracts.UniSwapGraph.ScalarCodecs.codecs |> Contracts.UniSwapGraph.Scalar.unwrapEncoder .codecId) ]) object_ (identity >> Decode.nullable)


type alias TokenDayDatasOptionalArguments =
    { skip : OptionalArgument Int
    , first : OptionalArgument Int
    , orderBy : OptionalArgument Contracts.UniSwapGraph.Enum.TokenDayData_orderBy.TokenDayData_orderBy
    , orderDirection : OptionalArgument Contracts.UniSwapGraph.Enum.OrderDirection.OrderDirection
    , where_ : OptionalArgument Contracts.UniSwapGraph.InputObject.TokenDayData_filter
    , block : OptionalArgument Contracts.UniSwapGraph.InputObject.Block_height
    }


{-|

  - block - The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.

-}
tokenDayDatas :
    (TokenDayDatasOptionalArguments -> TokenDayDatasOptionalArguments)
    -> SelectionSet decodesTo Contracts.UniSwapGraph.Object.TokenDayData
    -> SelectionSet (List decodesTo) RootSubscription
tokenDayDatas fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { skip = Absent, first = Absent, orderBy = Absent, orderDirection = Absent, where_ = Absent, block = Absent }

        optionalArgs =
            [ Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum Contracts.UniSwapGraph.Enum.TokenDayData_orderBy.toString), Argument.optional "orderDirection" filledInOptionals.orderDirection (Encode.enum Contracts.UniSwapGraph.Enum.OrderDirection.toString), Argument.optional "where" filledInOptionals.where_ Contracts.UniSwapGraph.InputObject.encodeTokenDayData_filter, Argument.optional "block" filledInOptionals.block Contracts.UniSwapGraph.InputObject.encodeBlock_height ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tokenDayDatas" optionalArgs object_ (identity >> Decode.list)
